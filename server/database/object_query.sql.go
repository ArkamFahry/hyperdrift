// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: object_query.sql

package database

import (
	"context"
	"time"
)

const createObject = `-- name: CreateObject :one
insert into storage.objects
    (bucket_id, name, mime_type, size, metadata, upload_status)
values ($1,
        $2,
        $3,
        $4,
        $5,
        $6)
returning id
`

type CreateObjectParams struct {
	BucketID     string
	Name         string
	ContentType  *string
	Size         int64
	Metadata     []byte
	UploadStatus string
}

func (q *Queries) CreateObject(ctx context.Context, arg *CreateObjectParams) (string, error) {
	row := q.db.QueryRow(ctx, createObject,
		arg.BucketID,
		arg.Name,
		arg.ContentType,
		arg.Size,
		arg.Metadata,
		arg.UploadStatus,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteObject = `-- name: DeleteObject :exec
delete
from storage.objects
where id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteObject, id)
	return err
}

const getObjectByBucketIdAndName = `-- name: GetObjectByBucketIdAndName :one
select id,
       version,
       bucket_id,
       name,
       mime_type,
       size,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
  and name = $2
limit 1
`

type GetObjectByBucketIdAndNameParams struct {
	BucketID string
	Name     string
}

type GetObjectByBucketIdAndNameRow struct {
	ID             string
	Version        int32
	BucketID       string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectByBucketIdAndName(ctx context.Context, arg *GetObjectByBucketIdAndNameParams) (*GetObjectByBucketIdAndNameRow, error) {
	row := q.db.QueryRow(ctx, getObjectByBucketIdAndName, arg.BucketID, arg.Name)
	var i GetObjectByBucketIdAndNameRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.BucketID,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getObjectById = `-- name: GetObjectById :one
select id,
       version,
       bucket_id,
       name,
       mime_type,
       size,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where id = $1
limit 1
`

type GetObjectByIdRow struct {
	ID             string
	Version        int32
	BucketID       string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectById(ctx context.Context, id string) (*GetObjectByIdRow, error) {
	row := q.db.QueryRow(ctx, getObjectById, id)
	var i GetObjectByIdRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.BucketID,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getObjectByIdWithBucketName = `-- name: GetObjectByIdWithBucketName :one
select object.id,
       object.version,
       object.bucket_id,
       bucket.name as bucket_name,
       object.name,
       object.mime_type,
       object.size,
       object.metadata,
       object.upload_status,
       object.last_accessed_at,
       object.created_at,
       object.updated_at
from storage.objects as object
         inner join storage.buckets as bucket on object.bucket_id = bucket.id
where object.id = $1
limit 1
`

type GetObjectByIdWithBucketNameRow struct {
	ID             string
	Version        int32
	BucketID       string
	BucketName     string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectByIdWithBucketName(ctx context.Context, id string) (*GetObjectByIdWithBucketNameRow, error) {
	row := q.db.QueryRow(ctx, getObjectByIdWithBucketName, id)
	var i GetObjectByIdWithBucketNameRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.BucketID,
		&i.BucketName,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getObjectByName = `-- name: GetObjectByName :one
select id,
       version,
       bucket_id,
       name,
       mime_type,
       size,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where name = $1
limit 1
`

type GetObjectByNameRow struct {
	ID             string
	Version        int32
	BucketID       string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectByName(ctx context.Context, name string) (*GetObjectByNameRow, error) {
	row := q.db.QueryRow(ctx, getObjectByName, name)
	var i GetObjectByNameRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.BucketID,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listObjectsByBucketIdPaged = `-- name: ListObjectsByBucketIdPaged :many
select id,
       bucket_id,
       name,
       mime_type,
       size,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
limit $3 offset $2
`

type ListObjectsByBucketIdPagedParams struct {
	BucketID string
	Offset   int32
	Limit    int32
}

type ListObjectsByBucketIdPagedRow struct {
	ID             string
	BucketID       string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) ListObjectsByBucketIdPaged(ctx context.Context, arg *ListObjectsByBucketIdPagedParams) ([]*ListObjectsByBucketIdPagedRow, error) {
	rows, err := q.db.Query(ctx, listObjectsByBucketIdPaged, arg.BucketID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListObjectsByBucketIdPagedRow
	for rows.Next() {
		var i ListObjectsByBucketIdPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeObjectPrivate = `-- name: MakeObjectPrivate :exec
update storage.objects
set public = false
where id = $1
`

func (q *Queries) MakeObjectPrivate(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, makeObjectPrivate, id)
	return err
}

const makeObjectPublic = `-- name: MakeObjectPublic :exec
update storage.objects
set public = true
where id = $1
`

func (q *Queries) MakeObjectPublic(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, makeObjectPublic, id)
	return err
}

const mergeObjectMetadata = `-- name: MergeObjectMetadata :exec
update storage.objects
set metadata = metadata || $1
where id = $2
`

type MergeObjectMetadataParams struct {
	Metadata []byte
	ID       string
}

func (q *Queries) MergeObjectMetadata(ctx context.Context, arg *MergeObjectMetadataParams) error {
	_, err := q.db.Exec(ctx, mergeObjectMetadata, arg.Metadata, arg.ID)
	return err
}

const searchObjectsByBucketNameAndPath = `-- name: SearchObjectsByBucketNameAndPath :many
select object.id,
       object.version,
       object.bucket_id,
       object.name,
       object.mime_type,
       object.size,
       object.metadata,
       object.upload_status,
       object.last_accessed_at,
       object.created_at,
       object.updated_at
from storage.objects as object
where object.bucket_id = (select bucket.id from storage.buckets as bucket where bucket.name = $1)
  and object.name ilike $2::text || '%'
limit $4 offset $3
`

type SearchObjectsByBucketNameAndPathParams struct {
	BucketName string
	ObjectPath string
	Offset     int32
	Limit      int32
}

type SearchObjectsByBucketNameAndPathRow struct {
	ID             string
	Version        int32
	BucketID       string
	Name           string
	MimeType       string
	Size           int64
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) SearchObjectsByBucketNameAndPath(ctx context.Context, arg *SearchObjectsByBucketNameAndPathParams) ([]*SearchObjectsByBucketNameAndPathRow, error) {
	rows, err := q.db.Query(ctx, searchObjectsByBucketNameAndPath,
		arg.BucketName,
		arg.ObjectPath,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchObjectsByBucketNameAndPathRow
	for rows.Next() {
		var i SearchObjectsByBucketNameAndPathRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.BucketID,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObject = `-- name: UpdateObject :exec
update storage.objects
set size      = coalesce($1, size),
    mime_type = coalesce($2, mime_type),
    metadata  = coalesce($3, metadata)
where id = $4
`

type UpdateObjectParams struct {
	Size     int64
	MimeType string
	Metadata []byte
	ID       string
}

func (q *Queries) UpdateObject(ctx context.Context, arg *UpdateObjectParams) error {
	_, err := q.db.Exec(ctx, updateObject,
		arg.Size,
		arg.MimeType,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const updateObjectLastAccessedAt = `-- name: UpdateObjectLastAccessedAt :exec
update storage.objects
set last_accessed_at = now()
where id = $1
`

func (q *Queries) UpdateObjectLastAccessedAt(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, updateObjectLastAccessedAt, id)
	return err
}

const updateObjectUploadStatus = `-- name: UpdateObjectUploadStatus :exec
update storage.objects
set upload_status = $1
where id = $2
`

type UpdateObjectUploadStatusParams struct {
	UploadStatus string
	ID           string
}

func (q *Queries) UpdateObjectUploadStatus(ctx context.Context, arg *UpdateObjectUploadStatusParams) error {
	_, err := q.db.Exec(ctx, updateObjectUploadStatus, arg.UploadStatus, arg.ID)
	return err
}
