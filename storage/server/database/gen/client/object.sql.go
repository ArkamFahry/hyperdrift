// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: object.sql

package client

import (
	"context"
	"time"
)

const createObject = `-- name: CreateObject :exec
insert into storage.objects
    (id, bucket_id, name, size, mime_type, public, metadata)
values ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7)
returning id, bucket_id, name, path_tokens, mime_type, size, public, metadata, upload_status, last_accessed_at, created_at, updated_at
`

type CreateObjectParams struct {
	ID       string
	BucketID string
	Name     string
	MimeType int64
	Size     string
	Public   bool
	Metadata []byte
}

func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) error {
	_, err := q.db.Exec(ctx, createObject,
		arg.ID,
		arg.BucketID,
		arg.Name,
		arg.MimeType,
		arg.Size,
		arg.Public,
		arg.Metadata,
	)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
delete
from storage.objects
where id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteObject, id)
	return err
}

const getObjectByBucketIdAndName = `-- name: GetObjectByBucketIdAndName :one
select id,
       bucket_id,
       name,
       path_tokens,
       mime_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
  and name = $2
limit 1
`

type GetObjectByBucketIdAndNameParams struct {
	BucketID string
	Name     string
}

func (q *Queries) GetObjectByBucketIdAndName(ctx context.Context, arg GetObjectByBucketIdAndNameParams) (*StorageObject, error) {
	row := q.db.QueryRow(ctx, getObjectByBucketIdAndName, arg.BucketID, arg.Name)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Name,
		&i.PathTokens,
		&i.MimeType,
		&i.Size,
		&i.Public,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getObjectById = `-- name: GetObjectById :one
select id,
       bucket_id,
       name,
       path_tokens,
       mime_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where id = $1
limit 1
`

func (q *Queries) GetObjectById(ctx context.Context, id string) (*StorageObject, error) {
	row := q.db.QueryRow(ctx, getObjectById, id)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Name,
		&i.PathTokens,
		&i.MimeType,
		&i.Size,
		&i.Public,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listAllObjectsByBucketIdPaged = `-- name: ListAllObjectsByBucketIdPaged :many
select id,
       bucket_id,
       name,
       path_tokens,
       mime_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
limit $3 offset $2
`

type ListAllObjectsByBucketIdPagedParams struct {
	BucketID string
	Offset   int32
	Limit    int32
}

func (q *Queries) ListAllObjectsByBucketIdPaged(ctx context.Context, arg ListAllObjectsByBucketIdPagedParams) ([]*StorageObject, error) {
	rows, err := q.db.Query(ctx, listAllObjectsByBucketIdPaged, arg.BucketID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StorageObject
	for rows.Next() {
		var i StorageObject
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Name,
			&i.PathTokens,
			&i.MimeType,
			&i.Size,
			&i.Public,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeObjectPrivate = `-- name: MakeObjectPrivate :exec
update storage.objects
set public = false
where id = $1
`

func (q *Queries) MakeObjectPrivate(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, makeObjectPrivate, id)
	return err
}

const makeObjectPublic = `-- name: MakeObjectPublic :exec
update storage.objects
set public = true
where id = $1
`

func (q *Queries) MakeObjectPublic(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, makeObjectPublic, id)
	return err
}

const mergeObjectMetadata = `-- name: MergeObjectMetadata :exec
update storage.objects
set metadata = metadata || $1
where id = $2
`

type MergeObjectMetadataParams struct {
	Metadata []byte
	ID       string
}

func (q *Queries) MergeObjectMetadata(ctx context.Context, arg MergeObjectMetadataParams) error {
	_, err := q.db.Exec(ctx, mergeObjectMetadata, arg.Metadata, arg.ID)
	return err
}

const searchObjectsByPath = `-- name: SearchObjectsByPath :many
select id::text,
       bucket::text,
       name::text,
       mime_type::text,
       size::bigint,
       public::boolean,
       metadata::jsonb,
       upload_status::text,
       last_accessed_at::timestamptz,
       created_at::timestamptz,
       updated_at::timestamptz
from storage.objects_search($1::text, $2::text,$3::int,
                            $4::int, $5::int)
`

type SearchObjectsByPathParams struct {
	BucketName string
	PathPrefix string
	Levels     *int32
	Limit      *int32
	Offset     *int32
}

type SearchObjectsByPathRow struct {
	ID             string
	Bucket         string
	Name           string
	MimeType       string
	Size           int64
	Public         bool
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) SearchObjectsByPath(ctx context.Context, arg SearchObjectsByPathParams) ([]*SearchObjectsByPathRow, error) {
	rows, err := q.db.Query(ctx, searchObjectsByPath,
		arg.BucketName,
		arg.PathPrefix,
		arg.Levels,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchObjectsByPathRow
	for rows.Next() {
		var i SearchObjectsByPathRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.Public,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObject = `-- name: UpdateObject :exec
update storage.objects
set
    size = coalesce($1, size),
    mime_type = coalesce($2, mime_type),
    metadata = coalesce($3, metadata)
where id = $4
`

type UpdateObjectParams struct {
	Size     int64
	MimeType string
	Metadata []byte
	ID       string
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) error {
	_, err := q.db.Exec(ctx, updateObject,
		arg.Size,
		arg.MimeType,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const updateObjectLastAccessedAt = `-- name: UpdateObjectLastAccessedAt :exec
update storage.objects
set last_accessed_at = now()
where id = $1
`

func (q *Queries) UpdateObjectLastAccessedAt(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, updateObjectLastAccessedAt, id)
	return err
}

const updateObjectUploadStatus = `-- name: UpdateObjectUploadStatus :exec
update storage.objects
set upload_status = $1
where id = $2
`

type UpdateObjectUploadStatusParams struct {
	UploadStatus string
	ID           string
}

func (q *Queries) UpdateObjectUploadStatus(ctx context.Context, arg UpdateObjectUploadStatusParams) error {
	_, err := q.db.Exec(ctx, updateObjectUploadStatus, arg.UploadStatus, arg.ID)
	return err
}
