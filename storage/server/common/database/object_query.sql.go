// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: object_query.sql

package database

import (
	"context"
	"time"
)

const createObject = `-- name: CreateObject :exec
insert into storage.objects
    (id, bucket_id, name, content_type, size, public, metadata)
values ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7)
returning id, version, bucket_id, name, path_tokens, content_type, size, public, metadata, upload_status, last_accessed_at, created_at, updated_at
`

type CreateObjectParams struct {
	ID          string
	BucketID    string
	Name        string
	ContentType string
	Size        int64
	Public      bool
	Metadata    []byte
}

func (q *Queries) CreateObject(ctx context.Context, arg *CreateObjectParams) error {
	_, err := q.db.Exec(ctx, createObject,
		arg.ID,
		arg.BucketID,
		arg.Name,
		arg.ContentType,
		arg.Size,
		arg.Public,
		arg.Metadata,
	)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
delete
from storage.objects
where id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteObject, id)
	return err
}

const getObjectByBucketIdAndName = `-- name: GetObjectByBucketIdAndName :one
select id,
       bucket_id,
       name,
       path_tokens,
       content_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
  and name = $2
limit 1
`

type GetObjectByBucketIdAndNameParams struct {
	BucketID string
	Name     string
}

type GetObjectByBucketIdAndNameRow struct {
	ID             string
	BucketID       string
	Name           string
	PathTokens     []string
	ContentType    string
	Size           int64
	Public         bool
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectByBucketIdAndName(ctx context.Context, arg *GetObjectByBucketIdAndNameParams) (*GetObjectByBucketIdAndNameRow, error) {
	row := q.db.QueryRow(ctx, getObjectByBucketIdAndName, arg.BucketID, arg.Name)
	var i GetObjectByBucketIdAndNameRow
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Name,
		&i.PathTokens,
		&i.ContentType,
		&i.Size,
		&i.Public,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getObjectById = `-- name: GetObjectById :one
select id,
       bucket_id,
       name,
       path_tokens,
       content_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where id = $1
limit 1
`

type GetObjectByIdRow struct {
	ID             string
	BucketID       string
	Name           string
	PathTokens     []string
	ContentType    string
	Size           int64
	Public         bool
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) GetObjectById(ctx context.Context, id string) (*GetObjectByIdRow, error) {
	row := q.db.QueryRow(ctx, getObjectById, id)
	var i GetObjectByIdRow
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Name,
		&i.PathTokens,
		&i.ContentType,
		&i.Size,
		&i.Public,
		&i.Metadata,
		&i.UploadStatus,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listAllObjectsByBucketIdPaged = `-- name: ListAllObjectsByBucketIdPaged :many
select id,
       bucket_id,
       name,
       path_tokens,
       content_type,
       size,
       public,
       metadata,
       upload_status,
       last_accessed_at,
       created_at,
       updated_at
from storage.objects
where bucket_id = $1
limit $3 offset $2
`

type ListAllObjectsByBucketIdPagedParams struct {
	BucketID string
	Offset   int32
	Limit    int32
}

type ListAllObjectsByBucketIdPagedRow struct {
	ID             string
	BucketID       string
	Name           string
	PathTokens     []string
	ContentType    string
	Size           int64
	Public         bool
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt *time.Time
	CreatedAt      time.Time
	UpdatedAt      *time.Time
}

func (q *Queries) ListAllObjectsByBucketIdPaged(ctx context.Context, arg *ListAllObjectsByBucketIdPagedParams) ([]*ListAllObjectsByBucketIdPagedRow, error) {
	rows, err := q.db.Query(ctx, listAllObjectsByBucketIdPaged, arg.BucketID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListAllObjectsByBucketIdPagedRow
	for rows.Next() {
		var i ListAllObjectsByBucketIdPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Name,
			&i.PathTokens,
			&i.ContentType,
			&i.Size,
			&i.Public,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeObjectPrivate = `-- name: MakeObjectPrivate :exec
update storage.objects
set public = false
where id = $1 and version = $2
`

type MakeObjectPrivateParams struct {
	ID      string
	Version int32
}

func (q *Queries) MakeObjectPrivate(ctx context.Context, arg *MakeObjectPrivateParams) error {
	_, err := q.db.Exec(ctx, makeObjectPrivate, arg.ID, arg.Version)
	return err
}

const makeObjectPublic = `-- name: MakeObjectPublic :exec
update storage.objects
set public = true
where id = $1 and version = $2
`

type MakeObjectPublicParams struct {
	ID      string
	Version int32
}

func (q *Queries) MakeObjectPublic(ctx context.Context, arg *MakeObjectPublicParams) error {
	_, err := q.db.Exec(ctx, makeObjectPublic, arg.ID, arg.Version)
	return err
}

const mergeObjectMetadata = `-- name: MergeObjectMetadata :exec
update storage.objects
set metadata = metadata || $1
where id = $2 and version = $3
`

type MergeObjectMetadataParams struct {
	Metadata []byte
	ID       string
	Version  int32
}

func (q *Queries) MergeObjectMetadata(ctx context.Context, arg *MergeObjectMetadataParams) error {
	_, err := q.db.Exec(ctx, mergeObjectMetadata, arg.Metadata, arg.ID, arg.Version)
	return err
}

const searchObjectsByPath = `-- name: SearchObjectsByPath :many
select id::text,
       bucket::text,
       name::text,
       content_type::text,
       size::bigint,
       public::boolean,
       metadata::jsonb,
       upload_status::text,
       last_accessed_at::timestamptz,
       created_at::timestamptz,
       updated_at::timestamptz
from storage.objects_search($1::text, $2::text, $3::int,
                            $4::int, $5::int)
`

type SearchObjectsByPathParams struct {
	BucketName string
	PathPrefix string
	Levels     *int32
	Limit      *int32
	Offset     *int32
}

type SearchObjectsByPathRow struct {
	ID             string
	Bucket         string
	Name           string
	ContentType    string
	Size           int64
	Public         bool
	Metadata       []byte
	UploadStatus   string
	LastAccessedAt time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) SearchObjectsByPath(ctx context.Context, arg *SearchObjectsByPathParams) ([]*SearchObjectsByPathRow, error) {
	rows, err := q.db.Query(ctx, searchObjectsByPath,
		arg.BucketName,
		arg.PathPrefix,
		arg.Levels,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchObjectsByPathRow
	for rows.Next() {
		var i SearchObjectsByPathRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Name,
			&i.ContentType,
			&i.Size,
			&i.Public,
			&i.Metadata,
			&i.UploadStatus,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObject = `-- name: UpdateObject :exec
update storage.objects
set size         = coalesce($1, size),
    content_type = coalesce($2, content_type),
    metadata     = coalesce($3, metadata)
where id = $4 and version = $5
`

type UpdateObjectParams struct {
	Size        int64
	ContentType string
	Metadata    []byte
	ID          string
	Version     int32
}

func (q *Queries) UpdateObject(ctx context.Context, arg *UpdateObjectParams) error {
	_, err := q.db.Exec(ctx, updateObject,
		arg.Size,
		arg.ContentType,
		arg.Metadata,
		arg.ID,
		arg.Version,
	)
	return err
}

const updateObjectLastAccessedAt = `-- name: UpdateObjectLastAccessedAt :exec
update storage.objects
set last_accessed_at = now()
where id = $1 and version = $2
`

type UpdateObjectLastAccessedAtParams struct {
	ID      string
	Version int32
}

func (q *Queries) UpdateObjectLastAccessedAt(ctx context.Context, arg *UpdateObjectLastAccessedAtParams) error {
	_, err := q.db.Exec(ctx, updateObjectLastAccessedAt, arg.ID, arg.Version)
	return err
}

const updateObjectUploadStatus = `-- name: UpdateObjectUploadStatus :exec
update storage.objects
set upload_status = $1
where id = $2 and version = $3
`

type UpdateObjectUploadStatusParams struct {
	UploadStatus string
	ID           string
	Version      int32
}

func (q *Queries) UpdateObjectUploadStatus(ctx context.Context, arg *UpdateObjectUploadStatusParams) error {
	_, err := q.db.Exec(ctx, updateObjectUploadStatus, arg.UploadStatus, arg.ID, arg.Version)
	return err
}
